<file> ::= <module-part> <stmts>

<module-part> ::= [ MODULE IDENTIFIER ";" ] { IMPORT <import-name> [ AS IDENTIFIER ] ";" }
<import-name> ::= IDENTIFIER [ "." "*" ] | <header-name>
<header-name> ::= "<" TOKENS ">"

/// ===========================================================================
///  Statements
/// ===========================================================================
/// Note that ‘statement’ in this language is even more of a syntactic concept
/// than in e.g. C or C++: Whether an expression is a statement has nothing to
/// do with whether it returns a value; instead, a ‘statement’ is something that
/// may occur *only* as a direct child of a BlockExpr or at the top-level of the
/// file. The only reason were even using the term ‘statement’ for this is because
/// ‘TopLevelExpr’ sounds a bit stupid when there is already a term that conveys
/// pretty much the same, at least syntactically.
///
/// This is to prevent weird edge cases wrt e.g. lifetimes: for example, checking
/// whether a forward goto is valid becomes substantially more complicated if every
/// random subexpression of an expression inbetween the goto and the target could
/// be a defer expression.
///
/// Branching into the middle of an expression is similarly problematic, which is
/// why labels are also statements. Generally, these restrictions will have virtually
/// no impact on actual code since you’d have to be clinically insane to attempt any
/// of the things that this syntactic restriction is intended to prevent.
///
/// Generally, we prefer to make everything an expression, unless there is an explicit
/// reason not to do so.
<stmts> ::= { <stmt> | <pragma> }
<stmt>  ::= <expr>
          | <stmt-labelled>
          | <stmt-export>
          | <stmt-defer>
          | <decl>

<stmt-labelled>  ::= IDENTIFIER ":" <stmt>
<stmt-export>    ::= EXPORT <stmt>
<stmt-defer>     ::= DEFER <implicit-block>
/// ===========================================================================
///  Expressions
/// ===========================================================================
<expr> ::= <expr-invoke>
         | <expr-proc>
         | <expr-literal>
         | <expr-if>
         | <expr-decl-ref>
         | <expr-access>
         | <expr-block>
         | <expr-prefix>
         | <expr-binary>
         | <expr-assert>
         | <expr-return>
         | <expr-cast>
         | <expr-while>
         | <expr-loop-ctrl>
         | <expr-jump>
         | <expr-qual-name>
         | <expr-paren>
         | <expr-subscript>
         | <expr-for-in>
         | <expr-alias>
         | <expr-with>
         | <expr-tuple>
         | <type-struct>

<expr-assert>    ::= ASSERT <expr> [ ","  <expr> ]
<expr-invoke>    ::= <expr> [ "(" ] <expr> { "," <expr> } [ ")" ]
<expr-proc>      ::= <proc-extern> | <proc-named>
<expr-block>     ::= "{" <stmts> "}"
<expr-decl-ref>  ::= IDENTIFIER
<expr-access>    ::= [ <expr> ] "." [ IDENTIFIER | INIT ]
<expr-literal>   ::= INTEGER_LITERAL | STRING_LITERAL | <array-literal>
<expr-prefix>    ::= <prefix-op> <expr>
<expr-binary>    ::= <expr> <binary-op> <expr>
<expr-if>        ::= IF <expr> <then> { ELIF <expr> <then> } [ ELSE <implicit-block> ]
<expr-return>    ::= RETURN [ <expr> ]
<expr-cast>      ::= <expr> ( "as" | "as!" ) <type>
<expr-while>     ::= WHILE <expr> <do>
<expr-for-in>    ::= FOR IDENTIFIER IN <expr> <do>
<expr-loop-ctrl> ::= ( BREAK | CONTINUE ) [ IDENTIFIER ]
<expr-jump>      ::= GOTO IDENTIFIER
<expr-qual-name> ::= <expr> "::" IDENTIFIER
<expr-paren>     ::= "(" <expr> ")"
<expr-subscript> ::= <expr> "[" <expr> "]"
<expr-alias>     ::= ALIAS IDENTIFIER "=" <expr>
<expr-with>      ::= WITH <expr> [ <do> ]
<expr-tuple>     ::= "(" { <expr> "," } [ <expr> ] ")"

<proc-extern>    ::= PROC IDENTIFIER <proc-signature>
<proc-named>     ::= PROC IDENTIFIER <proc-signature> <proc-body>
<proc-signature> ::= [ <proc-params> ] { <proc-attrs> } [ <proc-ret> ]
<proc-params>    ::= "(" <parameter> { "," <parameter> } ")"
<proc-ret>       ::= "->" <type>
<proc-body>      ::= <expr-block> | "=" <implicit-block>
<proc-attrs>     ::= EXTERN | NOMANGLE
<parameter>      ::= [ WITH ] <param-decl>
<param-decl>     ::= <type> [ IDENTIFIER ] | PROC [ IDENTIFIER ] <proc-signature>
<then>           ::= [ THEN ] <implicit-block>
<do>             ::= [ DO ] <implicit-block>
<array-literal>  ::= "[" { <expr>  "," } [ <expr> ] "]"
<implicit-block> ::= <stmt> /// Syntactically any statement, but wrapped in an implicit block if it isn’t already one.
<prefix-op>      ::= /// All prefix operators.
<binary-op>      ::= /// All binary operators.

/// ===========================================================================
///  Declarations
/// ==========================================================================
<decl>           ::= <linkage-decl>
<linkage-decl>   ::= <proc-named> | <proc-extern> | <var-decl>
<var-decl>       ::= <type> IDENTIFIER [ "=" <expr> ]
<type-struct>    ::= STRUCT <name> <struct-rest>
<struct-anon>    ::= STRUCT <struct-rest>
<struct-rest>    ::= "{" { <struct-field> | <init-decl> } "}"
<struct-field>   ::= <var-decl>
<init-decl>      ::= INIT <proc-signature> <proc-body>

/// ===========================================================================
///  Types
/// ===========================================================================
<type>           ::= <type-prim>
                   | <type-qualified>
                   | <type-named>
                   | <type-struct>
                   | <type-tuple>
                   | <struct-anon>
<type-prim>      ::= INTEGER_TYPE | INT | BOOL | NIL | VOID | NORETURN | VAR
<type-named>     ::= IDENTIFIER
<type-tuple>     ::= "(" { <type> "," } [ <type> ] ")"
<type-qualified> ::= <type> { <type-qual> }
<type-qual>      ::= "&" | "^" | "?" | "[" [ <expr> ] "]"

/// ===========================================================================
///  Pragmas
/// ===========================================================================
<pragma>         ::= PRAGMA "nomangle" ";"
