<file> ::= <module-part> <exprs>

<module-part> ::= [ MODULE IDENTIFIER ";" ] { IMPORT IDENTIFIER }

/// ===========================================================================
///  Expressions
/// ===========================================================================
<exprs> ::= { <expr> | <pragma> | ";" }

<expr> ::= <expr-invoke>
         | <expr-proc>
         | <expr-literal>
         | <expr-if>
         | <expr-decl-ref>
         | <expr-access>
         | <expr-block>
         | <expr-prefix>
         | <expr-binary>
         | <expr-assert>
         | <expr-return>
         | <expr-defer>
         | <expr-cast>
         | <expr-while>
         | <expr-labelled>
         | <expr-loop-ctrl>
         | <expr-jump>
         | <expr-export>
         | <expr-qual-name>
         | <expr-paren>
         | <expr-subscript>
         | <type-struct>
         | <decl>

<expr-assert>    ::= ASSERT <expr> [ ","  <expr> ]
<expr-invoke>    ::= <expr> [ "(" ] <expr> { "," <expr> } [ ")" ]
<expr-proc>      ::= <proc-extern> | <proc-named>
<expr-block>     ::= "{" <exprs> "}"
<expr-decl-ref>  ::= IDENTIFIER
<expr-access>    ::= [ <expr> ] "." IDENTIFIER
<expr-literal>   ::= INTEGER_LITERAL | STRING_LITERAL
<expr-prefix>    ::= <prefix-op> <expr>
<expr-binary>    ::= <expr> <binary-op> <expr>
<expr-if>        ::= IF <expr> <then> { ELIF <expr> <then> } [ ELSE <implicit-block> ]
<expr-return>    ::= RETURN [ <expr> ]
<expr-defer>     ::= DEFER <implicit-block>
<expr-cast>      ::= <expr> ( "as" | "as!" ) <type>
<expr-while>     ::= WHILE <expr> <do>
<expr-labelled>  ::= IDENTIFIER ":" <expr>
<expr-loop-ctrl> ::= ( BREAK | CONTINUE ) [ IDENTIFIER ]
<expr-jump>      ::= GOTO IDENTIFIER
<expr-export>    ::= EXPORT <expr>
<expr-qual-name> ::= <expr> "::" IDENTIFIER
<expr-paren>     ::= "(" <expr> ")"
<expr-subscript> ::= <expr> "[" <expr> "]"

<proc-extern>    ::= PROC IDENTIFIER <proc-signature>
<proc-named>     ::= PROC IDENTIFIER <proc-signature> <proc-body>
<proc-signature> ::= [ <proc-params> ] { <proc-attrs> } [ <proc-ret> ]
<proc-params>    ::= "(" <param-decl> { "," <param-decl> } ")"
<proc-ret>       ::= "->" <type>
<proc-body>      ::= <expr-block> | "=" <implicit-block>
<proc-attrs>     ::= EXTERN | NOMANGLE
<param-decl>     ::= <type> [ IDENTIFIER ] | PROC [ IDENTIFIER ] <proc-signature>
<then>           ::= [ THEN ] <implicit-block>
<do>             ::= [ DO ] <implicit-block>
<implicit-block> ::= <expr> /// Syntactically any expression, but wrapped in an implicit block if it isnâ€™t already one.
<prefix-op>      ::= /// All prefix operators.
<binary-op>      ::= /// All binary operators.

/// ===========================================================================
///  Declarations
/// ==========================================================================
<decl>           ::= <linkage-decl>
<linkage-decl>   ::= <proc-named> | <proc-extern> | <var-decl>
<var-decl>       ::= <type> IDENTIFIER [ "=" <expr> ]
<type-struct>    ::= STRUCT <name> <struct-rest>
<struct-anon>    ::= STRUCT <struct-rest>
<struct-rest>    ::= "{" { <struct-field> | <init-decl> } "}"
<struct-field>   ::= <var-decl>
<init-decl>      ::= INIT <proc-signature> <proc-body>

/// ===========================================================================
///  Types
/// ===========================================================================
<type>           ::= <type-prim> | <type-qualified> | <type-named> | <type-struct> | <struct-anon>
<type-prim>      ::= INTEGER_TYPE | INT
<type-named>     ::= IDENTIFIER
<type-qualified> ::= <type> { <type-qual> }
<type-qual>      ::= "&" | "^" | "[" [ <expr> ] "]"

/// ===========================================================================
///  Pragmas
/// ===========================================================================
<pragma>         ::= PRAGMA "nomangle" ";"
