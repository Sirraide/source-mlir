#include <source/Frontend/Sema.hh>

/// ===========================================================================
///  Helpers
/// ===========================================================================
bool src::Sema::Convert(Expr*& e, Expr* type) {
    /// Sanity checks.
    if (e->sema.errored or type->sema.errored) return false;
    Assert(type->sema.ok, "Cannot convert to unanalysed type");
    Assert(isa<Type>(type));
    auto from = e->type;
    auto to = type->as_type;

    /// Place conversions involving reference first, as we may
    /// have to chain several conversions to get e.g. from an
    /// `i32&` to an `i64`.
    if (isa<ReferenceType>(from) or isa<ReferenceType>(to)) {
        /// Base types are equal.
        if (Type::Equal(from.strip_refs, to.strip_refs)) {
            auto from_depth = from.ref_depth;
            auto to_depth = to.ref_depth;

            /// If the depth we’re converting to is one greater than
            /// the depth of the expression, and the expression is an
            /// lvalue, then this is reference binding.
            if (to_depth == from_depth + 1 and e->is_lvalue) {
                e = new (mod) CastExpr(CastKind::LValueToReference, e, type, e->location);
                Analyse(e);
            }

            /// If the depth of the type we’re converting to is less than
            /// the depth of the type we’re converting from, then this is
            /// implicit dereferencing.
            else if (to_depth < from_depth) {
                InsertImplicitDereference(e, from_depth - to_depth);
            }
        }
    }

    /// If the types are equal, then they’re convertible to one another.
    from = e->type;
    to = type->as_type;
    if (Type::Equal(from, to)) return true;

    /// Smaller integer types can be converted to larger integer types.
    if (from.is_int(true) and to.is_int(true)) {
        auto from_size = from.size(mod->context);
        auto to_size = to.size(mod->context);
        if (from_size <= to_size) {
            InsertImplicitCast(e, type);
            return true;
        }

        /// No other valid integer conversions.
        return false;
    }

    /// No other conversions are supported.
    return false;
}

void src::Sema::InsertImplicitCast(Expr*& e, Expr* to) {
    Expr* cast = new (mod) CastExpr(CastKind::Implicit, e, to, e->location);
    Analyse(cast);
    e = cast;
}

void src::Sema::InsertImplicitDereference(Expr*& e, isz depth) {
    for (isz i = depth; i; i--) {
        e = new (mod) CastExpr(
            CastKind::ReferenceToLValue,
            e,
            Type::Unknown,
            e->location
        );

        Analyse(e);
    }
}

void src::Sema::InsertLValueToRValueConversion(Expr*& e) {
    if (not e->sema.errored and e->is_lvalue) {
        Expr* cast = new (mod) CastExpr(
            CastKind::LValueToRValue,
            e,
            Type::Unknown,
            e->location
        );

        Analyse(cast);
        e = cast;
    }
}

template <bool in_array>
bool src::Sema::MakeDeclType(Expr*& e) {
    if (not AnalyseAsType(e)) return false;
    if (Type::Equal(e, Type::Void)) {
        if constexpr (in_array) return Error(e, "Cannot declare an array of type 'void'");
        else return Error(e, "Cannot declare a variable of type 'void'");
    }

    /// IDEA: `proc&` is a function pointer, `proc^` a closure.
    if (isa<ProcType>(e)) return Error(e, "Sorry, closures are not supported yet");
    return true;
}

/// ===========================================================================
///  Analysis
/// ===========================================================================
bool src::Sema::Analyse(Expr*& e) {
    /// Don’t analyse the same expression twice.
    if (e->sema.analysed or e->sema.in_progress) return e->sema.ok;
    if (e->sema.errored) return false;
    e->sema.set_in_progress();
    defer { e->sema.set_done(); };
    switch (e->kind) {
        /// No-ops.
        case Expr::Kind::BuiltinType:
        case Expr::Kind::FFIType:
        case Expr::Kind::SugaredType:
            break;

        /// Only generated by sema and always type checked.
        case Expr::Kind::ConstExpr:
            Unreachable();

        /// Bools are of type bool.
        case Expr::Kind::BoolLiteralExpr:
            cast<BoolLitExpr>(e)->stored_type = BuiltinType::Bool(mod, e->location);
            break;

        /// Integers are of type int.
        case Expr::Kind::IntegerLiteralExpr:
            cast<IntLitExpr>(e)->stored_type = BuiltinType::Int(mod, e->location);
            break;

        /// String literals are u8 slices.
        case Expr::Kind::StringLiteralExpr: {
            auto str = cast<StrLitExpr>(e);
            auto loc = str->location;
            Expr* u8 = IntType::Create(mod, 8);
            Analyse(u8);

            /// Unlike in C++, string literals are *not* lvalues; rather a
            /// new string slice is constructed every time a string literal
            /// is used.
            str->stored_type = new (mod) SliceType(u8, loc);
            Analyse(str->stored_type);
        } break;

        /// Handled out of line because it’s too complicated.
        case Expr::Kind::ProcDecl:
            AnalyseProcedure(cast<ProcDecl>(e));
            break;

        /// `i0` is illegal.
        case Expr::Kind::IntType:
            if (cast<IntType>(e)->bits == 0) Error(e, "Integer type bit width cannot be 0");
            break;

        /// Array size must be a valid constant expression.
        case Expr::Kind::ArrayType: {
            auto arr = cast<ArrayType>(e);
            if (not Analyse(arr->dim_expr)) return e->sema.set_errored();

            /// TODO: Proper constant expression evaluation.
            auto integer = dyn_cast<IntLitExpr>(arr->dim_expr);
            if (not integer) return Error(e, "Sorry, non-trivial constant expression evaluation is not supported yet");
            arr->dim_expr = new (mod) ConstExpr(arr->dim_expr, integer->value, integer->location);

            /// Element type must be legal in a declaration.
            if (not AnalyseAsType(arr->elem) or not MakeDeclType<true>(arr->elem))
                return e->sema.set_errored();
        } break;

        /// No restrictions here, but check the element types.
        case Expr::Kind::ReferenceType:
        case Expr::Kind::ScopedPointerType:
        case Expr::Kind::OptionalType:
        case Expr::Kind::SliceType:
            /// TODO: Type inference and checking that we don’t have e.g. `void[]`.
            Analyse(cast<SingleElementTypeBase>(e)->elem);
            break;

        /// Parameters and return type must be complete.
        case Expr::Kind::ProcType: {
            auto type = cast<ProcType>(e);

            for (auto& param : type->param_types) {
                if (not AnalyseAsType(param) or not MakeDeclType(param)) e->sema.set_errored();
                else if (Type::Equal(param, Type::Unknown)) {
                    e->sema.set_errored();
                    Error(param, "Type inference is not permitted here");
                }
            }

            if (not AnalyseAsType(type->ret_type)) e->sema.set_errored();
        } break;

        /// Structures.
        case Expr::Kind::StructType: {
            auto s = cast<StructType>(e);
            usz padding_count = 0;

            /// Create a padding field at the given location.
            const auto CreatePaddingField = [&](isz padding, auto insert_before) {
                /// Field decl.
                Expr* decl = new (mod) VarDecl(
                    nullptr,
                    fmt::format("#padding{}", padding_count++),
                    new (mod) ArrayType(Type::I8, new (mod) IntLitExpr(padding / 8, s->location), s->location),
                    nullptr,
                    Linkage::Local,
                    Mangling::Source,
                    s->location
                );

                /// Should never fail.
                Assert(Analyse(decl) and isa<VarDecl>(decl));

                /// Create a new member to serve as padding.
                StructType::Field f(cast<VarDecl>(decl));
                f.offset = s->stored_size;
                f.padding = true;
                s->all_fields.insert(insert_before, f);
                s->stored_size += padding;
            };

            /// Helper to align a field to its alignment.
            const auto AlignField = [&](isz alignment, usz& it) {
                /// Check if we need to insert padding.
                auto pad = utils::AlignTo<isz>(utils::AlignPadding(s->stored_size, alignment), 8);
                if (pad == 0) return;
                CreatePaddingField(pad, s->all_fields.begin() + it);

                /// Move iterator forward past the padding to the actual element.
                it++;
            };

            /// Members must all be valid decls.
            ///
            /// We iterate using an index to avoid iterator invalidation, as we
            /// may have to insert padding fields as we go.
            for (usz i = 0; i < s->all_fields.size(); i++) {
                if (
                    auto& f = s->all_fields[i];
                    not AnalyseAsType(f.decl->stored_type) or
                    not MakeDeclType(f.decl->stored_type)
                ) {
                    e->sema.set_errored();
                    continue;
                }

                /// Set offset of each field and determine the size and alignment
                /// of the struct.
                auto align = s->all_fields[i].decl->type.align(mod->context);
                AlignField(align, i);
                s->all_fields[i].offset = s->stored_size;
                s->stored_alignment = std::max<isz>(s->stored_alignment, align);
                s->stored_size += s->all_fields[i].decl->type.size(mod->context);
            }

            /// Size must be a multiple of the alignment.
            auto pad = utils::AlignTo<isz>(utils::AlignPadding(s->stored_size, s->stored_alignment), 8);
            if (pad != 0) CreatePaddingField(pad, s->all_fields.end());
        } break;

        /// Deferred expression.
        case Expr::Kind::DeferExpr: {
            /// Defer expressions have nothing to typecheck really, so
            /// we just check the operand and leave it at that. Even
            /// nested `defer defer` expressions, albeit degenerate, are
            /// accepted.
            Analyse(cast<DeferExpr>(e)->expr);
        } break;

        /// Loop control expressions.
        case Expr::Kind::LoopControlExpr: {
            auto l = cast<LoopControlExpr>(e);

            /// Find the label if there is one.
            if (not l->label.empty()) {
                auto target = curr_proc->labels.find(l->label);
                if (target == curr_proc->labels.end()) {
                    Error(l->location, "Unknown label '{}'", l->label);
                    break;
                }

                /// Set the target to the label and make sure we’re
                /// actually inside that loop.
                l->target = target->getValue();
                for (auto loop : vws::reverse(loop_stack))
                    if (cast<WhileExpr>(loop)->label == l->label)
                        goto done;
                Error(
                    l->target,
                    "Cannot {} to label '{}' from outside loop",
                    l->is_continue ? "continue" : "break",
                    l->label
                );
            }

            /// Otherwise, the target is the parent.
            else {
                /// No loop to break out of or continue.
                if (loop_stack.empty()) {
                    Error(
                        l->location,
                        "'{}' is invalid outside of loops",
                        l->is_continue ? "continue" : "break"
                    );
                    break;
                }

                l->target = loop_stack.back();
            }
        } break;

        /// Return expressions.
        case Expr::Kind::ReturnExpr: {
            auto r = cast<ReturnExpr>(e);
            if (r->value and not Analyse(r->value)) return e->sema.set_errored();

            /// If we’re in a `= <expr>` procedure, and the return type
            /// is unspecified, infer the return type from this return
            /// expression.
            auto ret = curr_proc->ret_type;
            if (Type::Equal(ret, Type::Unknown)) {
                cast<ProcType>(curr_proc->stored_type)->ret_type =
                    not r->value ? Type::Void : r->value->type;
            }

            /// Check for noreturn.
            else if (Type::Equal(ret, Type::NoReturn)) {
                if (r->value and not Type::Equal(r->value, Type::NoReturn)) Error(
                    e,
                    "'noreturn' function may not return"
                );
            }

            /// Return expression returns a value. Check that the return value
            /// is convertible to the return type.
            else if (r->value) {
                if (not Convert(r->value, ret)) Error(
                    e,
                    "Cannot return a value of type '{}' from a function with return type '{}'",
                    r->value->type,
                    Type::Void->as_type
                );
            }

            /// Return expression has no argument.
            else {
                if (not Type::Equal(ret, Type::Void)) {
                    Error(
                        e,
                        "Function declared with return type '{}' must return a value",
                        r->value->type
                    );
                }
            }
        } break;

        /// Assertions take a bool and an optional message.
        case Expr::Kind::AssertExpr: {
            auto a = cast<AssertExpr>(e);
            if (Analyse(a->cond) and not Convert(a->cond, Type::Bool)) {
                Error(
                    a->cond->location,
                    "Condition of 'assert' must be of type '{}', but was '{}'",
                    Type::Bool->as_type,
                    a->cond->type
                );
            }

            /// Get the condition as a source string.
            a->message_string = a->cond->location.seekable(mod->context)
                                  ? fmt::format("Assertion failed: '{}'", a->cond->location.text(mod->context))
                                  : "Assertion failed: <invalid source location>";

            /// Append the message if there is one.
            if (a->msg) {
                auto s = dyn_cast<StrLitExpr>(a->msg);
                if (not s) Diag::ICE(
                    mod->context,
                    a->msg->location,
                    "Sorry, assertion message must currently be a string literal"
                );

                /// Exclude null terminator.
                auto v = mod->strtab[s->index];
                a->message_string += fmt::format(". Message: {}", v.substr(0, v.size() - 1));
            }
        } break;

        /// The type of a block is the type of the last expression.
        case Expr::Kind::BlockExpr: {
            auto b = cast<BlockExpr>(e);
            tempset curr_scope = b->scope;
            long last = std::ssize(b->exprs) - 1;
            for (auto&& [i, expr] : vws::enumerate(b->exprs)) {
                if (not Analyse(expr) and i == last) e->sema.set_errored();
                else if (i == last) {
                    b->stored_type = expr->type;
                    b->is_lvalue = expr->is_lvalue;
                }
            }

            /// If the type could not be determined, set it to void.
            if (Type::Equal(b->stored_type, Type::Unknown)) b->stored_type = Type::Void;
        } break;

        /// An invoke expression may be a procedure call, or a declaration.
        case Expr::Kind::InvokeExpr: {
            /// Analyse the callee first.
            auto invoke = cast<InvokeExpr>(e);
            if (not Analyse(invoke->callee)) return e->sema.set_errored();

            /// If the callee is of function type, and not a type itself,
            /// then this is a function call.
            ///
            /// Invoke expression handling is defined as part of overload resolution,
            /// so until we have that, the rules are:
            /// - The result of an invoke expression is an rvalue.
            /// - The operands of an invoke expressions must be rvalues.
            if (auto ptype = dyn_cast<ProcType>(invoke->callee->type); ptype and not isa<Type>(invoke->callee)) {
                /// Analyse the arguments.
                for (auto& arg : invoke->args)
                    if (not Analyse(arg))
                        e->sema.set_errored();

                /// Make sure the types match.
                for (auto&& [param, arg] : llvm::zip(ptype->param_types, invoke->args)) {
                    if (not Convert(arg, param)) {
                        e->sema.set_errored();
                        Error(
                            arg,
                            "Argument type '{}' is not convertible to parameter type '{}'",
                            arg->type,
                            param
                        );
                    } else {
                        InsertLValueToRValueConversion(arg);
                    }
                }

                /// Make sure there are as many arguments as parameters.
                if (invoke->args.size() != ptype->param_types.size()) {
                    e->sema.set_errored();
                    Error(
                        invoke,
                        "Expected {} arguments, but got {}",
                        ptype->param_types.size(),
                        invoke->args.size()
                    );
                }

                /// The type of the expression is the return type of the
                /// callee. Invoke expressions are never lvalues.
                invoke->stored_type = ptype->ret_type;
            }

            /// Otherwise, if the callee is a type, then this is a declaration.
            else if (isa<Type>(invoke->callee)) {
                if (not MakeDeclType(invoke->callee)) e->sema.set_errored();

                /// The arguments must be DeclRefExprs.
                for (auto& arg : invoke->args) {
                    if (not isa<DeclRefExpr>(arg)) {
                        e->sema.set_errored();
                        Error(arg, "Expected identifier in declaration");
                    }
                }

                /// Helper to create a var decl.
                auto MakeVar = [&](Expr* name, Expr* init) -> VarDecl* {
                    return new (mod) VarDecl(
                        curr_proc,
                        cast<DeclRefExpr>(name)->name,
                        invoke->callee,
                        init,
                        Linkage::Local,
                        Mangling::Source,
                        name->location
                    );
                };

                /// Rewrite the invocation to a declaration. Type checking
                /// for the initialiser is done elsewhere.
                if (invoke->args.size() == 1) {
                    e = MakeVar(invoke->args.front(), invoke->init);
                    return Analyse(e);
                }

                /// If the invoke expression contains multiple declarations
                /// rewrite to a VarListDecl expr.
                else {
                    Todo();
                }
            }

            /// Otherwise, no idea what this is supposed to be.
            else {
                e->sema.set_errored();
                Error(invoke->callee, "Expected procedure or type");
            }
        } break;

        /// Cast expression.
        case Expr::Kind::CastExpr: {
            auto m = cast<CastExpr>(e);
            Analyse(m->operand);
            switch (m->cast_kind) {
                /// Only generated by sema. Converts an lvalue to an rvalue.
                case CastKind::LValueToRValue:
                    m->stored_type = m->operand->type;
                    break;

                /// Only generated by sema. Dereference a reference
                /// once, yielding an lvalue.
                case CastKind::ReferenceToLValue:
                    if (m->operand->is_lvalue) m->cast_kind = CastKind::LValueRefToLValue;
                    m->stored_type = cast<ReferenceType>(m->operand->type)->elem;
                    m->is_lvalue = true;
                    break;

                /// Should only be generated by the case above.
                case CastKind::LValueRefToLValue: Unreachable();

                /// Only generated by sema. Convert an lvalue to a reference. The
                /// result is an *rvalue* of reference type.
                case CastKind::LValueToReference:
                    m->stored_type = new (mod) ReferenceType(m->operand->type, m->location);
                    break;

                /// Only generated by sema. No-op here. Currently, there
                /// is no implicit cast that yields an lvalue.
                case CastKind::Implicit: break;

                /// Explicit cast.
                case CastKind::Soft:
                case CastKind::Hard:
                    AnalyseExplicitCast(e, m->cast_kind == CastKind::Hard);
                    break;
            }
        } break;

        /// Member access into a type.
        case Expr::Kind::MemberAccessExpr: {
            auto m = cast<MemberAccessExpr>(e);
            if (not Analyse(m->object)) return e->sema.set_errored();

            /// Dereference the object until we get an lvalue.
            InsertImplicitDereference(m->object, m->object->type.ref_depth);
            auto desugared = m->object->type.desugared.strip_refs;

            /// A slice type has a `data` and a `size` member.
            ///
            /// Neither of these are lvalues since slices are
            /// supposed to be pretty much immutable, and you
            /// should create a new one rather than changing
            /// the size or the data pointer.
            if (auto slice = dyn_cast<SliceType>(desugared)) {
                if (m->member == "data") {
                    m->stored_type = new (mod) ReferenceType(slice->elem, m->location);
                    return Analyse(m->stored_type);
                }

                if (m->member == "size") {
                    m->stored_type = BuiltinType::Int(mod, m->location);
                    return true;
                }

                return Error(m, "Type '{}' has no '{}' member", slice, m->member);
            }

            /// Struct field accesses are lvalues.
            if (auto s = dyn_cast<StructType>(desugared)) {
                auto fields = s->fields();
                auto f = rgs::find(fields, m->member, [](auto& f) { return f.decl->name; });
                if (f == fields.end()) return Error(m, "Type '{}' has no '{}' member", s, m->member);

                m->field = &*f;
                m->stored_type = m->field->decl->stored_type;
                m->is_lvalue = true;
                return true;
            }

            return Error(m, "Cannot perform member access on type '{}'", m->object->type);
        }

        /// Perform name lookup in scope.
        case Expr::Kind::DeclRefExpr: {
            auto* d = cast<DeclRefExpr>(e);
            d->scope->visit(d->name, false, [&](auto&& decls) {
                Assert(not decls.empty(), "Ill-formed symbol table entry");

                /// If there are multiple declarations, take the last.
                Analyse(decls.back());
                d->decl = decls.back();
                return utils::StopIteration;
            });

            /// If we didn’t find anything, then this is an error.
            if (not d->decl) return Error(e, "Unknown symbol '{}'", d->name);

            /// The type of this is the type of the referenced expression.
            if (d->decl->sema.errored) d->sema.set_errored();
            else {
                /// If this is a type, replace it w/ a sugared type.
                if (isa<Type>(d->decl)) {
                    e->sema.unset(); /// Other instances of this will have to be replaced w/ this again.
                    e = new (mod) SugaredType(d->name, d->decl, d->location);
                }

                /// If it is a variable declaration, replace it w/ a variable reference.
                else if (auto var = dyn_cast<VarDecl>(d->decl)) {
                    e->sema.unset(); /// Other instances of this will have to be replaced w/ this again.
                    e = new (mod) VarRefExpr(var, d->location);
                    return Analyse(e);
                }

                /// Otherwise, this stays as a DeclRefExpr.
                else {
                    d->stored_type = d->decl->type;
                    d->is_lvalue = isa<ParamDecl>(d->decl);
                }
            }
        } break;

        /// Determine the static chain offset from a variable reference to
        /// its declaration. Type and lvalueness is already set by the ctor.
        case Expr::Kind::VarRefExpr: {
            auto var = cast<VarRefExpr>(e);
            for (auto proc = curr_proc; proc and proc != var->decl->parent; proc = proc->parent)
                var->static_chain_distance++;
        } break;

        /// Make sure the type is valid.
        case Expr::Kind::ParamDecl: {
            auto param = cast<ParamDecl>(e);
            if (not AnalyseAsType(param->stored_type) or not MakeDeclType(param->stored_type))
                return e->sema.set_errored();

            /// Add the parameter to the procedure body’s scope.
            if (not param->name.empty()) curr_proc->body->scope->declare(param->name, param);
            param->is_lvalue = true;
            /// TODO: Check for redeclaration?
        } break;

        /// Variable declaration.
        case Expr::Kind::VarDecl: {
            auto var = cast<VarDecl>(e);
            if (not AnalyseAsType(var->stored_type)) return e->sema.set_errored();

            /// If the type is unknown, then we must infer it from
            /// the initialiser.
            if (Type::Equal(var->stored_type, Type::Unknown)) {
                if (not var->init) return Error(var, "Type inference requires an initialiser");
                if (not Analyse(var->init)) return e->sema.set_errored();
                InsertLValueToRValueConversion(var->init);
                var->stored_type = var->init->type;
                if (not MakeDeclType(var->stored_type)) return e->sema.set_errored();
            }

            /// Otherwise, the type of the declaration must be valid, and if there
            /// is an initialiser, it must be convertible to the type of the variable.
            else {
                /// In a lambda to simplify early exit w/o returning from the parent.
                auto HandleInit = [&] -> void {
                    /// No need to set the variable itself to errored since we know its type.
                    if (not Analyse(var->init)) return;
                    if (not Convert(var->init, var->stored_type)) {
                        return (void) Error(
                            var->init,
                            "Initialiser type '{}' is not convertible to variable type '{}'",
                            var->init->type,
                            var->stored_type
                        );
                    }

                    /// The initialiser must be an rvalue.
                    InsertLValueToRValueConversion(var->init);
                };

                if (not MakeDeclType(var->stored_type)) return e->sema.set_errored();
                if (var->init) HandleInit();
            }

            /// Add the variable to the current scope.
            if (not var->sema.errored) {
                curr_scope->declare(var->name, var);
                var->is_lvalue = true;
            }
        } break;

        /// If expressions.
        case Expr::Kind::IfExpr: {
            auto i = cast<IfExpr>(e);

            /// If the condition has an error, the type of the if expression
            /// itself can still be determined as it is independent of the
            /// condition.
            if (Analyse(i->cond)) {
                if (Convert(i->cond, Type::Bool)) InsertLValueToRValueConversion(i->cond);
                else Error(
                    i->cond->location,
                    "Type '{}' of condition of `if` must be convertible to '{}'",
                    i->cond->type.str(true),
                    Type::Bool->as_type.str(true)
                );
            }

            /// Analyse the branches.
            if (not Analyse(i->then) or (i->else_ and not Analyse(i->else_)))
                return e->sema.set_errored();

            /// If there is an else clause, then the type of this expression is a bit
            /// more difficult to determine.
            if (i->else_) {
                /// In order to facilitate checking whether all paths in a function
                /// return a value, we must take care to not set the type to noreturn
                /// unless both branches are noreturn. This has to be a separate case
                /// since noreturn is convertible to any type.
                ///
                /// If only one branch is of type noreturn, that means that if this
                /// expression yields a value rather than returning, the value must
                /// be of the other branch’s type.
                if (i->then->type.is_noreturn or i->else_->type.is_noreturn) {
                    i->stored_type = not i->then->type.is_noreturn  ? i->then->type
                                   : not i->else_->type.is_noreturn ? i->else_->type
                                                                    : Type::NoReturn;
                }

                /// Otherwise, If the types of the then and else branch are convertible
                /// to one another, then the type of the if expression is that type.
                /// Furthermore, ensure that either both clauses are lvalues or neither
                /// is; in the former case, the entire expr is an lvalue.
                else if (Convert(i->else_, i->then->type) or Convert(i->then, i->else_->type)) {
                    i->stored_type = i->then->type;
                    if (i->then->is_lvalue and i->else_->is_lvalue) i->is_lvalue = true;
                    else {
                        /// Convert both to rvalues so we don’t end up w/ an lvalue in
                        /// one case and an rvalue in the other.
                        InsertLValueToRValueConversion(i->then);
                        InsertLValueToRValueConversion(i->else_);
                    }
                }
            } else {
                i->stored_type = Type::Void;
            }
        } break;

        /// While loops.
        case Expr::Kind::WhileExpr: {
            auto w = cast<WhileExpr>(e);
            if (Analyse(w->cond) and not Convert(w->cond, Type::Bool)) Error(
                w->cond->location,
                "Type '{}' of loop condition is not convertible to '{}'",
                w->cond->type.str(true),
                Type::Bool->as_type.str(true)
            );

            /// Condition is an rvalue.
            InsertLValueToRValueConversion(w->cond);

            /// There is nothing left to do other than analyse the body. The
            /// type of this is always void, so sema for the while expression
            /// itself can never fail.
            loop_stack.push_back(w);
            defer { loop_stack.pop_back(); };
            Analyse(w->body);
        } break;

        /// Unary expressions.
        case Expr::Kind::UnaryPrefixExpr: {
            auto u = cast<UnaryPrefixExpr>(e);
            if (not Analyse(u->operand)) return e->sema.set_errored();
            switch (u->op) {
                default: Unreachable("Invalid unary prefix operator");

                /// Explicit dereference.
                case Tk::Star: {
                    auto ref = dyn_cast<ReferenceType>(u->operand->type);
                    if (not ref) return Error(
                        u,
                        "Cannot dereference value of non-reference type '{}'",
                        u->operand->type
                    );

                    /// The type is the element type of the reference.
                    u->stored_type = ref->elem;
                    u->is_lvalue = true;
                } break;
            }
        } break;

        /// Binary operators are complicated.
        case Expr::Kind::BinaryExpr: {
            auto b = cast<BinaryExpr>(e);
            if (not Analyse(b->lhs) or not Analyse(b->rhs))
                return e->sema.set_errored();
            switch (b->op) {
                default: Unreachable("Invalid binary operator");

                /// Arithmetic operators.
                ///
                /// Note: `and` and `or` are emitted lazily, but this
                /// is irrelevant to semantic analysis, so we don’t
                /// care about that here.
                case Tk::Plus:
                case Tk::Minus:
                case Tk::Star:
                case Tk::StarStar:
                case Tk::Slash:
                case Tk::Percent:
                case Tk::And:
                case Tk::Or:
                case Tk::Xor:
                case Tk::ShiftLeft:
                case Tk::ShiftRight:
                case Tk::ShiftRightLogical: {
                    /// Operands are rvalues of non-reference type.
                    InsertLValueToRValueConversion(b->lhs);
                    InsertLValueToRValueConversion(b->rhs);

                    /// Both types must be integers.
                    if (
                        not b->lhs->type.is_int(true) or
                        not b->rhs->type.is_int(true)
                    ) return Error( //
                        b,
                        "Operands of '{}' must be integers, but got '{}' and '{}'",
                        Spelling(b->op),
                        b->lhs->type,
                        b->rhs->type
                    );

                    /// The smaller integer is cast to the larger type if they
                    /// don’t have the same size. Integer conversions from a
                    /// smaller to a larger type can never fail, which is why
                    /// we assert rather than error here.
                    if (not Type::Equal(b->lhs->type, b->rhs->type)) {
                        auto lsz = b->lhs->type.size(mod->context);
                        auto rsz = b->rhs->type.size(mod->context);
                        if (lsz >= rsz) Assert(Convert(b->rhs, b->lhs->type));
                        else Assert(Convert(b->lhs, b->rhs->type));
                    }

                    /// The result type is that integer type.
                    b->stored_type = b->lhs->type;
                } break;

                /// Comparison operators.
                case Tk::EqEq:
                case Tk::Neq:
                case Tk::Lt:
                case Tk::Gt:
                case Tk::Le:
                case Tk::Ge: {
                    /// Look through rvalues, but allow comparing references if
                    /// their addresses are taken.
                    InsertLValueToRValueConversion(b->lhs);
                    InsertLValueToRValueConversion(b->rhs);

                    /// Both types must be equal.
                    if (
                        not Convert(b->lhs, b->rhs->type) and
                        not Convert(b->rhs, b->lhs->type)
                    ) return Error( //
                        b,
                        "Cannot compare '{}' with '{}'",
                        Spelling(b->op),
                        b->lhs->type,
                        b->rhs->type
                    );

                    /// The type of a comparison is bool.
                    b->stored_type = BuiltinType::Bool(mod, b->location);
                } break;

                /// Value assignment. The LHS has to be an lvalue.
                case Tk::Assign: {
                    /// This operator never performs reference reassignment, which
                    /// means the LHS must not be of reference type.
                    InsertImplicitDereference(b->lhs, b->lhs->type.ref_depth);
                    if (not b->lhs->is_lvalue) return Error(
                        b,
                        "Left-hand side of `=` must be an lvalue"
                    );

                    /// The RHS must be convertible to the LHS.
                    if (not Convert(b->rhs, b->lhs->type)) return Error(
                        b,
                        "Cannot assign '{}' to '{}'",
                        b->rhs->type,
                        b->lhs->type
                    );

                    /// RHS is an rvalue.
                    InsertLValueToRValueConversion(b->rhs);

                    /// The type of the expression is the type of the LHS.
                    b->stored_type = b->lhs->type;
                    b->is_lvalue = true;
                } break;

                /// Reference assignment.
                ///
                /// See [expr.binary.refassign] for an explanation of the algorithm below.
                case Tk::RDblArrow: {
                    /// 1.
                    if (not isa<ReferenceType>(b->lhs->type)) return Error(
                        b,
                        "LHS of reference binding must be a reference, but was '{}'",
                        b->lhs->type
                    );

                    /// For error reporting *only*.
                    auto ltype_saved = b->lhs->type;
                    auto rtype_saved = b->rhs->type;

                    /// 2/3.
                    if (not b->lhs->is_lvalue) InsertImplicitDereference(b->lhs, 1);
                    if (not isa<ReferenceType>(b->lhs->type)) return Error(
                        b,
                        "LHS of reference binding is not an lvalue",
                        b->lhs->type
                    );

                    /// 4/5.
                    auto d_l = b->lhs->type.ref_depth;
                    auto d_r = b->rhs->type.ref_depth;
                    if (d_l < d_r) InsertImplicitDereference(b->rhs, d_r - d_l);
                    else if (d_r > d_l) InsertImplicitDereference(b->lhs, d_l - d_r);

                    /// 6.
                    if (not Convert(b->rhs, b->lhs->type)) {
                        if (
                            not Type::Equal(b->rhs->type, rtype_saved) or
                            not Type::Equal(b->lhs->type, ltype_saved)
                        ) {
                            Diag::Note(
                                mod->context,
                                b->location,
                                "In reference binding to '{}' from '{}'",
                                ltype_saved.str(true),
                                rtype_saved.str(true)
                            );
                        }

                        return Error(
                            b,
                            "No implicit conversion from '{}' to '{}'",
                            b->rhs->type,
                            b->lhs->type
                        );
                    }

                    /// 7.
                    InsertLValueToRValueConversion(b->rhs);
                    b->stored_type = b->lhs->type;
                    b->is_lvalue = true;
                } break;
            }
        }
    }

done:
    /// Can’t check for 'ok' as that may not be set yet.
    return not e->sema.errored;
}

bool src::Sema::AnalyseAsType(Expr*& e) {
    Analyse(e);
    if (e->sema.ok and not isa<Type>(e)) Error(e->location, "Not a type");
    return e->sema.ok;
}

void src::Sema::AnalyseExplicitCast(Expr*& e, [[maybe_unused]] bool is_hard) {
    auto c = cast<CastExpr>(e);

    /// Check the type. We can’t cast if there is a problem w/ it.
    if (not Analyse(c->stored_type) or not Analyse(c->operand)) {
        e->sema.set_errored();
        return;
    }

    /// The operand of a cast is an rvalue.
    ///
    /// TODO: This doesn’t allow lvalue to reference conversions
    ///       because, well, we need an lvalue for that. Do we
    ///       care about that?
    InsertLValueToRValueConversion(c->operand);

    /// If the types are convertible, then the cast is fine.
    if (Convert(c->operand, e->type)) return;

    /// Integer-to-integer conversions are fine.
    if (c->operand->type.is_int(true) and e->type.is_int(true)) return;

    /// Other conversions may be added in the future.
    /// TODO: Actually add some hard casts.
    Error(
        e,
        "Unsupported cast from '{}' to '{}'",
        c->operand->type,
        e->type
    );
}

void src::Sema::AnalyseProcedure(src::ProcDecl* proc) {
    tempset curr_proc = proc;

    /// Validate the function type.
    if (not AnalyseAsType(cast<TypedExpr>(proc)->stored_type))
        proc->sema.set_errored();

    /// If there is no body, then there is nothing to do.
    if (not proc->body) return;

    /// Sanity check.
    if (Type::Equal(proc->ret_type, Type::Unknown) and not proc->body->implicit) Diag::ICE(
        mod->context,
        proc->location,
        "Non-inferred procedure has unknown return type"
    );

    /// Add all named parameters to the body’s scope.
    for (auto* param : proc->params) {
        Expr* e = param;
        Analyse(e);
        Assert(e == param, "ParamDecls may not be replaced with another expression");
    }

    /// Analyse the body. If either it or the procedure
    /// contains an error, we can’t check if the procedure
    /// has a return statement.
    Expr* body = proc->body;
    Analyse(body);
    if (not body->sema.ok) return;

    /// If the body is `= <expr>`, infer the return type if
    /// there isn’t already one.
    ///
    /// Note that, if the type of the body is actually noreturn here,
    /// then this really is a noreturn function; if the body contains
    /// a return expression and is noreturn because of that, then the
    /// ret type would have already been inferred and would no longer
    /// be `unknown`, so we could never get here in that case.
    if (proc->body->implicit) {
        /// Infer type.
        if (Type::Equal(proc->ret_type, Type::Unknown))
            cast<ProcType>(proc->stored_type)->ret_type = body->type;

        /// Check that the type is valid.
        else {
            Scope* sc = proc->body->scope;
            Expr* e = proc->body;
            if (not Convert(e, proc->ret_type)) {
                Error(
                    e,
                    "Cannot convert '{}' to return type '{}'",
                    e->type,
                    proc->ret_type
                );
                return;
            }

            /// If the conversion changed the expression, we need to add
            /// another implicit block since the body of a procedure must
            /// be a block. This is kind of scuffed, so maybe consider
            /// dropping this requirement at some point?
            if (e != proc->body) {
                e = new (mod) BlockExpr(
                    sc,
                    {e},
                    e->location,
                    true
                );

                Analyse(e);
                Assert(isa<BlockExpr>(e));
                proc->body = cast<BlockExpr>(e);
            }
        }
    }

    /// Make sure all paths return a value.
    else if (not Type::Equal(proc->ret_type, Type::Void)) {
        if (not Type::Equal(body->type, Type::NoReturn)) Error(
            proc->location,
            "Procedure '{}' does not return a value on all paths",
            proc->name
        );
    }
}

void src::Sema::AnalyseModule() {
    curr_scope = mod->global_scope;

    /// Analyse all functions.
    for (auto& f : mod->functions) {
        Expr* e = f;
        Analyse(e);
        Assert(e == f, "ProcDecl may not be replaced with another expression");
    }
}
