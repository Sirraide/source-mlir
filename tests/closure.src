/// R %srcc %s --hlir

/// p nolit ^
/// d t %[a-zA-Z0-9_]+

/// p nolit .
/// d any .*?
/// p lit .

proc a = 22;

/// * hlir.func private @b
/// + (?<c>$t) = local
/// + store into $c
/// + (?<cval>$t) = load $any from $c
/// + (?<ret>$t) = invokeclosure $cval()
/// + return $ret
proc b (proc c -> int) = c();

/// u c
/// u ret
/// * hlir.func private @caller
/// + (?<vars>$t) = local
/// + (?<x>$t) = structgep $vars
/// + (?<twenty>$t) = arith.constant 20
/// + store into $x, i64 $twenty
/// + (?<cl1>$t) = makeclosure { @a, null }
/// + (?<b1ret>$t) = call @b($cl1)
/// + (?<cl2>$t) = makeclosure { @c, $vars }
/// + (?<b2ret>$t) = call @b($cl2)
/// + (?<ret>$t) = arith.addi $b1ret, $b2ret
/// + return $ret
proc caller() -> int {
    int x = 20;
    proc c = x;
    return b(a) + b(c);
}

caller()
