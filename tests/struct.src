/// R %srcc --hlir %s

/// p nolit .
/// d any .*?
/// d t %[0-9a-zA-Z_]+
/// p lit .[]

pragma nomangle;

struct S {
    i8 a;
    i64 b;
    i8 c;
    i32 d;
}

/// * hlir.func external @__src_main
/// + call @__src_static_init.__src_runtime
/// + $t = scope i8 {
/// + (?<S>$t) = local
/// + construct $S zeroinit
/// + (?<S1>$t) = load $any from $S
/// + $t = call @foo($S, $S1)
/// + yield
/// + }
/// + return

S s;
foo s, s;

/// Note: Index of `.a` is 0; index of `.c` is 3, because padding.
/// * hlir.func private @foo
/// + (?<A>$t) = local
/// + store into $A
/// + (?<B>$t) = local
/// + store into $B
/// + (?<ret>$t) = scope i8 {
/// + (?<Aref>$t) = load $any from $A
/// + (?<AAref>$t) = structgep $Aref[0]
/// + (?<AA>$t) = load i8 from $AAref
/// + (?<BCref>$t) = structgep $B[3]
/// + (?<BC>$t) = load i8 from $BCref
/// + (?<Sum>$t) = arith.addi $AA, $BC
/// + yield i8 $Sum
/// + }
/// + return i8 $ret
proc foo (S& a, S b) = a.a + b.c;
