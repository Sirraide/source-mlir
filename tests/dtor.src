proc a extern;
proc b extern;
proc q extern -> bool;

bool i = q();

/// `x` is not declared here, so this code does
/// not need to call its destructor.
if i then a();
else return;

/// Declare, but donâ€™t initialise, `x` and `d`.
int^ x;
int d;

/// `x` has not been used yet, so there is no reason
/// for it to be initialised and thus no reason for
/// it to be destructed.
if i return;

/// Initialisation of x. Explicit initialisation is
/// required for `x` since scoped pointers have no
/// default initialiser.
first_init: x => new int;

/// However, the int `d` is initialised implicitly.
use: x = d; /// Use of x.

/// Reassignment requires destruction of the old value.
x => new int;

/// Goto is needed to generate the spaghetti code
/// required to test this properly.
if i goto foo; /// This crosses a potential deletion.
else goto bar; /// This does not.

if i then delete x;
else {
    if i then a()
    else {
        /// Branch from init region to initialiser
        /// requires deletion first if there is no
        /// intervening use (this is a branch into
        /// a region not *strictly* dominated by an
        /// init block)
        goto first_init;
    }

    if i {
        /// Here, there is an intervening use, so
        /// no deletion this time
        goto use;
    }

    /// Use is ok since `x` has not been deleted yet.
    ///
    /// This branches to a block where `x` may be
    /// deleted, so it needs to delete it as well.
    bar: x = 5;
}

/// Destructor has already been called here.
if i return;

/// More blocks.
if i then a();
else foo:; /// Jump to here has to destroy `x`.

/// Destructor has already been called. No need to
/// do that here (implicit return).