/// R %srcc --hlir %s

/// d t %[0-9a-zA-Z_]+
/// d b \^bb[0-9]+

proc a extern;
proc b extern;
proc c extern;
proc d extern;
proc e extern;
proc f extern;
proc cond() extern -> bool;

/// * hlir.func external @__src_main
/// * (?<I>$t) = local
int i = 4;

defer a();
defer b();

if cond() {
    /// * (?<J>$t) = local
    int j = 5;
    defer c();

    /// Note that the first defer proc emitted is defer proc 0,
    /// which is why the proc for `defer c()` is proc 0.
    /// * (?<C1>$t) = call @cond
    /// + cf.cond_br $C1, (?<TRUE_1>$b)
    /// + $TRUE_1:
    /// + call inline fastcc @__src_defer_proc_0($I, $J)
    /// + call inline fastcc @__src_defer_proc_1($I)
    /// + return
    if cond() return;
    defer d();

    /// * call @d
    /// + call inline fastcc @__src_defer_proc_0($I, $J)
}

/// * (?<K>$t) = local
int k = 6;
defer e();

/// * (?<C2>$t) = call @cond
/// + cf.cond_br $C2, (?<TRUE_2>$b)
/// + $TRUE_2:
/// + call inline fastcc @__src_defer_proc_2($I, $K)
/// + call inline fastcc @__src_defer_proc_1($I)
/// + return
if cond() return;
defer f();

/// * call @f
/// + call inline fastcc @__src_defer_proc_2($I, $K)
/// + call inline fastcc @__src_defer_proc_1($I)
/// + return


/// * hlir.func private fastcc @__src_defer_proc_0
/// * call @c

/// * hlir.func private fastcc @__src_defer_proc_1
/// * call @b
/// + call @a

/// * hlir.func private fastcc @__src_defer_proc_2
/// * call @e