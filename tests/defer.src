/// R ./srcc --hlir %s

/// d t %[0-9a-zA-Z_]+
/// d b \^bb[0-9]+

proc a extern;
proc b extern;
proc c extern;
proc d extern;
proc e extern;
proc f extern;
proc cond() extern -> bool;

/// * func.func public @__src_main
/// * (?<I>$t) = hlir.local_var
int i = 4;

defer a();
defer b();

if cond() {
    /// * (?<J>$t) = hlir.local_var
    int j = 5;
    defer c();

    /// Note that the first defer proc emitted is defer proc 0,
    /// which is why the proc for `defer c()` is proc 0.
    /// * (?<C1>$t) = call_indirect
    /// + cf.cond_br $C1, (?<TRUE_1>$b)
    /// + $TRUE_1:
    /// + call @__src_defer_proc_0($I, $J)
    /// + call @__src_defer_proc_1($I)
    /// + return
    if cond() return;
    defer d();

    /// * (?<D>$t) = constant @d
    /// + call_indirect $D
    /// + call @__src_defer_proc_0($I, $J)
}

/// * (?<K>$t) = hlir.local_var
int k = 6;
defer e();

/// * (?<C2>$t) = call_indirect
/// + cf.cond_br $C2, (?<TRUE_2>$b)
/// + $TRUE_2:
/// + call @__src_defer_proc_2($I, $K)
/// + return
if cond() return;
defer f();

/// * (?<F>$t) = constant @f
/// + call_indirect $F
/// + call @__src_defer_proc_2($I, $K)
/// + return


/// * func.func private @__src_defer_proc_0
/// * (?<C>$t) = constant @c
/// + call_indirect $C

/// * func.func private @__src_defer_proc_1
/// * (?<B>$t) = constant @b
/// + call_indirect $B
/// * (?<A>$t) = constant @a
/// + call_indirect $A

/// * func.func private @__src_defer_proc_2
/// * (?<E>$t) = constant @e
/// + call_indirect $E
/// + call @__src_defer_proc_1