/// R %srcc %s --hlir

/// d t %[a-zA-Z0-9_]+
/// d b \^bb[0-9]+

proc a() extern;
proc b() extern;
proc c() extern;
proc d() extern;
proc e() extern;
proc f() extern;
proc g() extern;
proc h() extern;
proc i() extern;
proc j() extern;
proc k() extern;
proc l() extern;
/// * (?<T>$t) = hlir.local
bool t = true;

defer a();

/// * cf.br (?<COND1>$b)
/// + $COND1:
/// + (?<T1>$t) = hlir.load i1 from $T
/// + cf.cond_br $T1, (?<BODY1>$b), (?<EXIT1>$b)
/// + $BODY1:
while t {
    /// `foobar` is never branched to and it should thus
    /// not affect codegen at all.
    defer b();
    foobar: defer c();

    /// + cf.br (?<COND2>$b)
    /// + $COND2:
    /// + (?<T2>$t) = hlir.load i1 from $T
    /// + cf.cond_br $T2, (?<BODY2>$b), (?<EXIT2>$b)
    /// + $BODY2:
    loop: while t {
        /// + (?<Q>$t) = hlir.local
        /// + hlir.zeroinitialiser
        int q;
        defer d();

        /// + cf.br (?<COND3>$b)
        /// + $COND3:
        /// + (?<T3>$t) = hlir.load i1 from $T
        /// + cf.cond_br $T3, (?<BODY3>$b), (?<EXIT3>$b)
        /// + $BODY3:
        loop2: while t {
            defer e();

            /// + cf.br (?<COND4>$b)
            /// + $COND4:
            /// + (?<T4>$t) = hlir.load i1 from $T
            /// + cf.cond_br $T4, (?<BODY4>$b), (?<EXIT4>$b)
            /// + $BODY4:
            while t {
                defer f();

                /// Label is branched to and thus creates a new block.
                /// + cf.br (?<LABEL1>$b)
                /// + $LABEL1:
                same_region:

                /// 0 executes f()
                /// + (?<T5>$t) = hlir.load i1 from $T
                /// + cf.cond_br $T5, (?<THEN1>$b), (?<ELSE1>$b)
                /// + $THEN1:
                /// + call @__src_defer_proc_0($T, $Q)
                /// + cf.br $EXIT4
                if t then break;
                /// + $ELSE1:

                /// Branch upwards in the same region without crossing
                /// deferred material is simply a branch.
                /// + (?<Tg1>$t) = hlir.load i1 from $T
                /// + cf.cond_br $Tg1, (?<THENg1>$b), (?<ELSEg1>$b)
                /// + $THENg1:
                /// + cf.br $LABEL1
                if t then goto same_region;
                /// + $ELSEg1:

                defer g();

                /// 0 executes f()
                /// 1 executes g()
                /// 2 executes e()
                /// + (?<T6>$t) = hlir.load i1 from $T
                /// + cf.cond_br $T6, (?<THEN2>$b), (?<ELSE2>$b)
                /// + $THEN2:
                /// + call @__src_defer_proc_1($T, $Q)
                /// + call @__src_defer_proc_0($T, $Q)
                /// + call @__src_defer_proc_2($T, $Q)
                /// + cf.br $EXIT3
                if t then break loop2;
                /// + $ELSE2:

                /// 0 executes f()
                /// 1 executes g()
                /// + call @__src_defer_proc_1($T, $Q)
                /// + call @__src_defer_proc_0($T, $Q)
                /// + cf.br $COND4
            }

            /// + $EXIT4:
            /// + cf.br (?<LABEL2>$b)
            /// + $LABEL2:
            one_scope_up:
            defer h();

            /// + cf.br (?<COND5>$b)
            /// + $COND5:
            /// + (?<T7>$t) = hlir.load i1 from $T
            /// + cf.cond_br $T7, (?<BODY5>$b), (?<EXIT5>$b)
            /// + $BODY5:
            while t {
                /// + (?<W>$t) = hlir.local
                /// + hlir.zeroinitialiser
                int w;
                defer i();

                /// Simple forward goto.
                /// + (?<Tg2>$t) = hlir.load i1 from $T
                /// + cf.cond_br $Tg2, (?<THENg2>$b), (?<ELSEg2>$b)
                /// + $THENg2:
                /// + cf.br (?<LABEL3>$b)
                if t then goto forward;
                /// + $ELSEg2:

                /// This one is a bit more painful; we jump back across a
                /// deferred expression, which means we need to emit it when
                /// we branch.
                /// 3 executes i()
                /// 4 executes h()
                /// + (?<Tg3>$t) = hlir.load i1 from $T
                /// + cf.cond_br $Tg3, (?<THENg3>$b), (?<ELSEg3>$b)
                /// + $THENg3:
                /// + call @__src_defer_proc_3($T, $Q, $W)
                /// + call @__src_defer_proc_4($T, $Q)
                /// + cf.br $LABEL2
                if t then goto one_scope_up;

                /// This is the same as the previous goto, but it jumps
                /// out of the scope and forward.
                /// + $ELSEg3:
                /// + cf.br $LABEL3
                /// + $LABEL3:
                /// + (?<Tg4>$t) = hlir.load i1 from $T
                /// + cf.cond_br $Tg4, (?<THENg4>$b), (?<ELSEg4>$b)
                /// + $THENg4:
                /// + call @__src_defer_proc_3($T, $Q, $W)
                /// + cf.br (?<LABEL4>$b)
                forward: if t then goto forward2;
                /// + $ELSEg4

                /// 3 executes i()
                /// 4 executes h()
                /// 2 executes e()
                /// 5 executes d()
                /// + (?<T8>$t) = hlir.load i1 from $T
                /// + cf.cond_br $T8, (?<THEN3>$b), (?<ELSE3>$b)
                /// + $THEN3:
                /// + call @__src_defer_proc_3($T, $Q, $W)
                /// + call @__src_defer_proc_4($T, $Q)
                /// + call @__src_defer_proc_2($T, $Q)
                /// + call @__src_defer_proc_5($T, $Q)
                /// + cf.br $COND2
                if t then continue loop;
                /// + $ELSE3:

                /// + call @__src_defer_proc_3($T, $Q, $W)
                /// + cf.br $COND5
            }

            /// + $EXIT5:
            /// + cf.br $LABEL4
            /// + $LABEL4:
            forward2:

            /// + cf.br (?<COND6>$b)
            /// + $COND6:
            /// + (?<T9>$t) = hlir.load i1 from $T
            /// + cf.cond_br $T9, (?<BODY6>$b), (?<EXIT6>$b)
            /// + $BODY6:
            while t {
                defer j();

                /// 6 executes j()
                /// + (?<T10>$t) = hlir.load i1 from $T
                /// + cf.cond_br $T10, (?<THEN4>$b), (?<ELSE4>$b)
                /// + $THEN4:
                /// + call @__src_defer_proc_6($T, $Q)
                /// + cf.br $COND6
                if t then continue;
                /// + $ELSE4:

                /// 6 executes j()
                /// + (?<T11>$t) = hlir.load i1 from $T
                /// + cf.cond_br $T11, (?<THEN5>$b), (?<ELSE5>$b)
                /// + $THEN5:
                /// + call @__src_defer_proc_6($T, $Q)
                /// + cf.br $EXIT6
                if t then break;
                /// + $ELSE5:

                /// 6 executes j()
                /// 4 executes h()
                /// 2 executes e()
                /// 5 executes d()
                /// 7 executes c(), b()
                /// 8 executes a()
                /// + (?<T12>$t) = hlir.load i1 from $T
                /// + cf.cond_br $T12, (?<THEN6>$b), (?<ELSE6>$b)
                /// + $THEN6:
                /// + call @__src_defer_proc_6($T, $Q)
                /// + call @__src_defer_proc_4($T, $Q)
                /// + call @__src_defer_proc_2($T, $Q)
                /// + call @__src_defer_proc_5($T, $Q)
                /// + call @__src_defer_proc_7($T)
                /// + call @__src_defer_proc_8($T)
                /// + return
                if t then return;
                /// + $ELSE6:


                defer k();

                /// 9 executes k(), j()
                /// 4 executes h()
                /// 2 executes e()
                /// 5 executes d()
                /// + (?<T13>$t) = hlir.load i1 from $T
                /// + cf.cond_br $T13, (?<THEN7>$b), (?<ELSE7>$b)
                /// + $THEN7:
                /// + call @__src_defer_proc_9($T, $Q)
                /// + call @__src_defer_proc_4($T, $Q)
                /// + call @__src_defer_proc_2($T, $Q)
                /// + call @__src_defer_proc_5($T, $Q)
                /// + cf.br $EXIT2
                if t break loop;
                /// + $ELSE7:

                /// 9 executes k(), j()
                /// 4 executes h()
                /// 2 executes e()
                /// + (?<T14>$t) = hlir.load i1 from $T
                /// + cf.cond_br $T14, (?<THEN8>$b), (?<ELSE8>$b)
                /// + $THEN8:
                /// + call @__src_defer_proc_9($T, $Q)
                /// + call @__src_defer_proc_4($T, $Q)
                /// + call @__src_defer_proc_2($T, $Q)
                /// + cf.br $COND3
                if t continue loop2;
                /// + $ELSE8:

                /// 9 executes k(), j()
                /// + call @__src_defer_proc_9($T, $Q)
                /// + cf.br $COND6
            }

            /// 2 executes e()
            /// 4 executes h()
            /// + $EXIT6:
            /// + call @__src_defer_proc_4($T, $Q)
            /// + call @__src_defer_proc_2($T, $Q)
            /// + cf.br $COND3
        }

        /// + $EXIT3:
        defer l();

        /// 10 executes l(), d()
        /// + (?<T15>$t) = hlir.load i1 from $T
        /// + cf.cond_br $T15, (?<THEN9>$b), (?<ELSE9>$b)
        /// + $THEN9:
        /// + call @__src_defer_proc_10($T, $Q)
        /// + cf.br $EXIT2
        if t then break;
        /// + $ELSE9:

        /// 10 executes l(), d()
        /// + call @__src_defer_proc_10($T, $Q)
        /// + cf.br $COND2
    }

    /// 7 executes c(), b()
    /// + $EXIT2:
    /// + call @__src_defer_proc_7($T)
    /// + cf.br $COND1
}

/// 8 executes a()
/// + $EXIT1:
/// + call @__src_defer_proc_8($T)
/// + return

/// =========================== FUNCTIONS ===========================
/// 0 executes f()
/// * func.func private @__src_defer_proc_0
/// + (?<F>$t) = constant @f
/// + call_indirect $F
/// + return

/// 1 executes g()
/// * func.func private @__src_defer_proc_1
/// + (?<G>$t) = constant @g
/// + call_indirect $G
/// + return

/// 2 executes e()
/// * func.func private @__src_defer_proc_2
/// + (?<E>$t) = constant @e
/// + call_indirect $E
/// + return

/// 3 executes i()
/// * func.func private @__src_defer_proc_3
/// + (?<I>$t) = constant @i
/// + call_indirect $I
/// + return

/// 4 executes h()
/// * func.func private @__src_defer_proc_4
/// + (?<H>$t) = constant @h
/// + call_indirect $H
/// + return

/// 5 executes d()
/// * func.func private @__src_defer_proc_5
/// + (?<D>$t) = constant @d
/// + call_indirect $D
/// + return

/// 6 executes j()
/// * func.func private @__src_defer_proc_6
/// + (?<J>$t) = constant @j
/// + call_indirect $J
/// + return

/// 7 executes c(), b()
/// * func.func private @__src_defer_proc_7
/// + (?<C>$t) = constant @c
/// + call_indirect $C
/// + (?<B>$t) = constant @b
/// + call_indirect $B
/// + return

/// 8 executes a()
/// * func.func private @__src_defer_proc_8
/// + (?<A>$t) = constant @a
/// + call_indirect $A
/// + return

/// 9 executes k(), j()
/// * func.func private @__src_defer_proc_9
/// + (?<K>$t) = constant @k
/// + call_indirect $K
/// + call @__src_defer_proc_6
/// + return

/// 10 executes l(), d()
/// * func.func private @__src_defer_proc_10
/// + (?<L>$t) = constant @l
/// + call_indirect $L
/// + call @__src_defer_proc_5
/// + return