/// ================ Main Control-Flow Test ================
///
/// This file is absurd for a test case, simply because it tests
/// interactions between all manner of control-flow constructs,
/// which, due to the nature of control flow, pretty much have to
/// be tested all together in one place to ensure they work properly
/// with one another, so...
///
/// ‘Lasciate ogne speranza, voi ch’intrate’
///      – Dante
///
/// R %srcc %s --hlir
/// d t %[a-zA-Z0-9_]+
/// d b \^bb[0-9]+

proc a() extern;
proc b() extern;
proc c() extern;
proc d() extern;
proc e() extern;
proc f() extern;
proc g() extern;
proc h() extern;
proc i() extern;
proc j() extern;
proc k() extern;
proc l() extern;
proc m() extern;
proc n() extern;
proc o() extern;

///  * hlir.func external @__src_main {
///  + scope {
///  + (?<T>$t) = local i1
bool t = true;

///  * (?<Da>$t) = defer {
///  +   call @a
///  +   yield
///  + }
defer a();

///  + cf.br (?<COND1>$b)
///  + $COND1:
///  + (?<T1>$t) = load i1 from $T
///  + cf.cond_br $T1, (?<BODY1>$b), (?<EXIT1>$b)
///  + $BODY1:
///  + scope {
while t {
    /// `unused` is never branched to and should thus
    /// not affect codegen at all.
    ///  + (?<Db>$t) = defer {
    ///  +   call @b
    ///  +   yield
    ///  + }
    ///  + (?<Dc>$t) = defer {
    ///  +   call @c
    ///  +   yield
    ///  + }
    defer b();
    unused: defer c();

    ///  + cf.br (?<COND2>$b)
    ///  + $COND2:
    ///  + (?<T2>$t) = load i1 from $T
    ///  + cf.cond_br $T2, (?<BODY2>$b), (?<EXIT2>$b)
    ///  + $BODY2:
    ///  + scope {
    loop: while t {
        ///  + (?<Q>$t) = local uninit i64
        int q;

        ///  + (?<Dd>$t) = defer {
        ///  +   call @d
        ///  +   yield
        ///  + }
        defer d();

        ///  + cf.br (?<COND3>$b)
        ///  + $COND3:
        ///  + (?<T3>$t) = load i1 from $T
        ///  + cf.cond_br $T3, (?<BODY3>$b), (?<EXIT3>$b)
        ///  + $BODY3:
        ///  + scope {
        loop2: while t {
            ///  + (?<De>$t) = defer {
            ///  +   call @e
            ///  +   yield
            ///  + }
            defer e();

            ///  + cf.br (?<COND4>$b)
            ///  + $COND4:
            ///  + (?<T4>$t) = load i1 from $T
            ///  + cf.cond_br $T4, (?<BODY4>$b), (?<EXIT4>$b)
            ///  + $BODY4:
            ///  + scope {
            while t {
                ///  + scope {
                ///  + scope {
                ///  + scope {
                ///  + cf.br (?<LABEL5>$b)
                ///  + $LABEL5:
                ///  + yield
                ///  + }
                ///  + yield
                ///  + }
                ///  + yield
                ///  + }
                { { { nested:; } } }

                ///  + (?<Df>$t) = defer {
                ///  +   call @f
                ///  +   yield
                ///  + }
                defer f();

                /// Label is branched to and thus creates a new block.
                ///  + cf.br (?<LABEL1>$b)
                ///  + $LABEL1:
                same_region:

                ///  + (?<T5>$t) = load i1 from $T
                ///  + cf.cond_br $T5, (?<THEN1>$b), (?<ELSE1>$b)
                ///  + $THEN1:
                ///  + scope {
                ///  +   directbr to $EXIT4
                ///  + }
                if t then break;
                ///  + cf.br $ELSE1
                ///  + $ELSE1:

                /// Branch upwards in the same region without crossing
                /// deferred material is simply a branch.
                ///  + (?<Tg1>$t) = load i1 from $T
                ///  + cf.cond_br $Tg1, (?<THENg1>$b), (?<ELSEg1>$b)
                ///  + $THENg1:
                ///  + scope {
                ///  +   directbr to $LABEL1
                ///  + }
                if t then goto same_region;
                ///  + cf.br $ELSEg1
                ///  + $ELSEg1:

                ///  + (?<Dg>$t) = defer {
                ///  +   call @g
                ///  +   yield
                ///  + }
                defer g();

                ///  + (?<T6>$t) = load i1 from $T
                ///  + cf.cond_br $T6, (?<THEN2>$b), (?<ELSE2>$b)
                ///  + $THEN2:
                ///  + scope {
                ///  +   directbr to $EXIT3
                ///  + }
                if t then break loop2;
                ///  + cf.br $ELSE2
                ///  + $ELSE2:

                ///  + yield
                ///  + }
            }

            ///  + cf.br $COND4
            ///  + $EXIT4:
            ///  + cf.br (?<LABEL2>$b)
            ///  + $LABEL2:
            one_scope_up:

            ///  + (?<Dh>$t) = defer {
            ///  +   call @h
            ///  +   yield
            ///  + }
            defer h();

            ///  + cf.br (?<COND5>$b)
            ///  + $COND5:
            ///  + (?<T7>$t) = load i1 from $T
            ///  + cf.cond_br $T7, (?<BODY5>$b), (?<EXIT5>$b)
            ///  + $BODY5:
            ///  + scope {
            while t {
                ///  + (?<W>$t) = local uninit i64
                int w;

                ///  + (?<Di>$t) = defer {
                ///  +   call @i
                ///  +   yield
                ///  + }
                defer i();

                /// Simple forward goto.
                ///  + (?<Tg2>$t) = load i1 from $T
                ///  + cf.cond_br $Tg2, (?<THENg2>$b), (?<ELSEg2>$b)
                ///  + $THENg2:
                ///  + scope {
                ///  +   directbr to (?<LABEL3>$b)
                ///  + }
                if t then goto forward;
                ///  + cf.br $ELSEg2
                ///  + $ELSEg2:

                /// This one is a bit more painful; we jump back across a
                /// deferred expression, which means we need to emit it when
                /// we branch.
                ///  + (?<Tg3>$t) = load i1 from $T
                ///  + cf.cond_br $Tg3, (?<THENg3>$b), (?<ELSEg3>$b)
                ///  + $THENg3:
                ///  + scope {
                ///  +   directbr to $LABEL2 unwind $Di, $W, $Dh
                ///  + }
                if t then goto one_scope_up;
                ///  + cf.br $ELSEg3
                ///  + $ELSEg3:

                /// This is the same as the previous goto, but it jumps
                /// out of the scope and forward.
                ///  + cf.br $LABEL3
                ///  + $LABEL3:
                ///  + (?<Tg4>$t) = load i1 from $T
                ///  + cf.cond_br $Tg4, (?<THENg4>$b), (?<ELSEg4>$b)
                ///  + $THENg4:
                ///  + scope {
                ///  +   directbr to (?<LABEL4>$b) unwind $Di, $W
                ///  + }
                forward: if t then goto forward2;
                ///  + cf.br $ELSEg4
                ///  + $ELSEg4

                /// Cross jump back into a different while loop.
                ///  + (?<Tg5>$t) = load i1 from $T
                ///  + cf.cond_br $Tg5, (?<THENg5>$b), (?<ELSEg5>$b)
                ///  + $THENg5:
                ///  + scope {
                ///  +   directbr to $LABEL5 unwind $Di, $W, $Dh
                ///  + }
                if t then goto nested;
                ///  + cf.br $ELSEg5
                ///  + $ELSEg5:

                ///  + (?<T8>$t) = load i1 from $T
                ///  + cf.cond_br $T8, (?<THEN3>$b), (?<ELSE3>$b)
                ///  + $THEN3:
                ///  + scope {
                ///  +   directbr to $COND2
                ///  + }
                if t then continue loop;
                ///  + cf.br $ELSE3
                ///  + $ELSE3:

                ///  + yield
                ///  + }
            }

            ///  + cf.br $COND5
            ///  + $EXIT5:
            ///  + cf.br $LABEL4
            ///  + $LABEL4:
            forward2:

            ///  + cf.br (?<COND6>$b)
            ///  + $COND6:
            ///  + (?<T9>$t) = load i1 from $T
            ///  + cf.cond_br $T9, (?<BODY6>$b), (?<EXIT6>$b)
            ///  + $BODY6:
            ///  + scope {
            while t {
                ///  + (?<Dj>$t) = defer {
                ///  +   call @j
                ///  +   yield
                ///  + }
                defer j();

                ///  + (?<T10>$t) = load i1 from $T
                ///  + cf.cond_br $T10, (?<THEN4>$b), (?<ELSE4>$b)
                ///  + $THEN4:
                ///  + scope {
                ///  +   directbr to $COND6
                ///  + }
                if t then continue;
                ///  + cf.br $ELSE4
                ///  + $ELSE4:

                ///  + (?<T11>$t) = load i1 from $T
                ///  + cf.cond_br $T11, (?<THEN5>$b), (?<ELSE5>$b)
                ///  + $THEN5:
                ///  + scope {
                ///  +   directbr to $EXIT6
                ///  + }
                if t then break;
                ///  + cf.br $ELSE5
                ///  + $ELSE5:

                ///  + (?<T12>$t) = load i1 from $T
                ///  + cf.cond_br $T12, (?<THEN6>$b), (?<ELSE6>$b)
                ///  + $THEN6:
                ///  + scope {
                ///  +   return
                ///  + }
                if t then return;
                ///  + cf.br $ELSE6
                ///  + $ELSE6:

                ///  + (?<k>$t) = defer {
                ///  +   call @k
                ///  +   yield
                ///  + }
                defer k();

                ///  + (?<T13>$t) = load i1 from $T
                ///  + cf.cond_br $T13, (?<THEN7>$b), (?<ELSE7>$b)
                ///  + $THEN7:
                ///  + scope {
                ///  +   directbr to $EXIT2
                ///  + }
                if t break loop;
                ///  + cf.br $ELSE7
                ///  + $ELSE7:

                ///  + (?<T14>$t) = load i1 from $T
                ///  + cf.cond_br $T14, (?<THEN8>$b), (?<ELSE8>$b)
                ///  + $THEN8:
                ///  + scope {
                ///  +   directbr to $COND3
                ///  + }
                if t continue loop2;
                ///  + cf.br $ELSE8
                ///  + $ELSE8:

                ///  + yield
                ///  + }
            }

            ///  + cf.br $COND6
            ///  + $EXIT6:
            ///  + yield
            ///  + }
        }

        ///  + cf.br $COND3
        ///  + $EXIT3:
        ///  + (?<Dl>$t) = defer {
        ///  +   call @l
        ///  +   yield
        ///  + }
        defer l();

        ///  + (?<T15>$t) = load i1 from $T
        ///  + cf.cond_br $T15, (?<THEN9>$b), (?<ELSE9>$b)
        ///  + $THEN9:
        ///  + scope {
        ///  +   directbr to $EXIT2
        ///  + }
        if t then break;
        ///  + cf.br $ELSE9
        ///  + $ELSE9:

        ///  + yield
        ///  + }
    }

    ///  + cf.br $COND2
    ///  + $EXIT2:
    ///  + yield
    ///  + }
}

///  + cf.br $COND1
///  + $EXIT1:
///  + yield
///  + }
///  + return
